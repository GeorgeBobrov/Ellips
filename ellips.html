<!DOCTYPE html>
<html>
<head>
<style>
* {
	box-sizing: border-box;
}

body {
	margin: 0px;
	user-select: none;
}


.panelMenu {
	padding: 0.3rem 0.5rem;
}  


#canvas_conteiner {
	position: relative;
	width: 1100px;
	height: 500px;  
	margin-bottom: 5px;
}

canvas {
	border: 1px solid #4d4e53;
	/* color:#4d5353; */
	/* position: absolute; */
}


#planet {
	border: 2px solid green;
	border-radius: 50%;
	position: absolute;
	width: 5px;
	height: 5px;  
	left: 1px;
	top: 1px;

	transform: translate(-50%, -50%);
}

</style>

	<title>Ellips</title>
	<link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./ellips.png" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
</head>
<body>
	<div class="panelMenu" id="panelMenu">

		<button class="buttonMenu" onclick="clear_overlay()">clear</button> 
		<button class="buttonMenu" onclick="run()">run</button> 
		<button class="buttonSetE_Earth" onclick="setE_Earth()">Set e of Earth</button> 
 
	</div>

	<label for="inputEccentricity">Eccentricity:</label>
	<input type="number" max="1" step="0.1" value="0.5" id="inputEccentricity">

	<input type = "checkbox" id="cbPause" >
	<label for="cbPause">PauseAnimation</label>
	<br>
	<div id="canvas_conteiner" >
		<canvas id="overlay" width="1100" height="500"></canvas>
		<div  id="planet" ></div>
	</div>
	<canvas id="chart" width="1200" height="200"></canvas>	

<script>

let chart = document.getElementById('chart')
let planet = document.getElementById('planet')
let checkboxPause = document.getElementById('cbPause')
let inputEccentricity = document.getElementById('inputEccentricity');
inputEccentricity.onchange = run


						
function clear_overlay() {
	let c = document.getElementById('overlay')
	c.getContext('2d').clearRect(0, 0, c.width, c.height)

	c = document.getElementById('chart')
	c.getContext('2d').clearRect(0, 0, c.width, c.height)	
}


function setE_Earth() {
	inputEccentricity.value = e_Earth
	run()
}

const G = 6.6743E-11
const M_Sun = 1.9885E+30
const μ	= G * M_Sun
const PerihelionEarth = 147_098_290_000
const e_Earth = 0.01671123
const M_Earth = 5.9726E24

const secInDay = 60 * 60 * 24

let Perihelion = 0
let a = 0 //Semi-major axis
let b = 0 //Semi-minor axis
let c = 0
let Aphelion = 0

let k_Earth = 0

let x_EllipsCentr = 0
let y_EllipsCentr = 0

let data_history = []
let color_i = 0
let animationStartTime = 0

function run() {
	const e = inputEccentricity.value
	// const a = 200 //Semi-major axis
	// const c = a * e
	// const Perihelion = a - c
	// const Aphelion = a + c

	Perihelion = 50
	a = Perihelion / (1 - e) //Semi-major axis
	b = a *  Math.sqrt(1 - e*e) //Semi-minor axis
	c = a * e
	Aphelion = a + c

	k_Earth = PerihelionEarth / Perihelion

	x_EllipsCentr = a + 20
	y_EllipsCentr = 250
	

	let ctx = document.getElementById('overlay').getContext('2d')


	ctx.lineWidth = 5
	ctx.strokeStyle = 'orange'

	// Draw Ellips focus
	// ctx.strokeRect(x_centr - c, y_centr, 5, 5)
	ctx.beginPath()
	ctx.ellipse(x_EllipsCentr - c, y_EllipsCentr, 4, 4, 0, 0, 2 * Math.PI)
	ctx.stroke()

	ctx.lineWidth = 1
	ctx.strokeStyle = 'black'
	// ctx.beginPath()
	// ctx.moveTo(x_centr, y_centr)
	// let first

	let speed_Perihelion = calcOrbitalSpeed(Perihelion*k_Earth, a*k_Earth)
	let speed_Aphelion = calcOrbitalSpeed(Aphelion*k_Earth, a*k_Earth)

	let LenOrbit = 4 * (Math.PI * a*b + (a-b)**2) / (a+b)

	let l1 = 3 * ((a-b) / (a+b))**2
	let LenOrbit2 = Math.PI * (a+b) * (1 + l1 / (10 + Math.sqrt(4 - l1)) )  

	let aE = a * k_Earth
	let Period = 2 * Math.PI * Math.sqrt((aE**3) / μ)
	
	console.log(`--------- Perihelion=${Perihelion.toFixed(1)}, Aphelion=${Aphelion.toFixed(1)}, e=${e} ----------`)


	let meanSpeedReached = false
	let halfPeriodReached = false
	let prevPos 
	let prevSpeed = 0
	let sumIntervals = 0
	let numMeanSpeedReached = 0
	let numHalfPeriodReached = 0

	data_history = []

	let startDaySeconds = new Date("01.01.2022").getTime()

	for (let alpha = 0; alpha <= 360; alpha+=3) {
		let alphaRad = alpha/180*Math.PI
		let curPos = calcDotPosition2(a, b, alphaRad)
		let {x, y} = curPos
		let FX = x - c
		R1 = Math.sqrt(FX*FX + y*y)

		let speed = calcOrbitalSpeed(R1*k_Earth, a*k_Earth)

		let deltaX = 0
		let deltaY = 0
		if (prevPos) {
			deltaX = x - prevPos.x
			deltaY = y - prevPos.y
		}

		let prevDistance = Math.sqrt(deltaX**2 + deltaY**2)
		let interval = prevDistance*k_Earth / speed
		sumIntervals += interval

		let date = new Date(startDaySeconds + sumIntervals * 1000)
		let dayIdeal = alpha / 360 * 365.25
		let dateIdeal = new Date(startDaySeconds + dayIdeal *secInDay*1000)


		let Epot = M_Earth * (μ / (R1*k_Earth))
		let Ekin = M_Earth * speed**2 / 2

		let hue = Math.round(15 + (1 - (speed / speed_Perihelion)) * 60)
		let lit = Math.round(50 - (1 - (speed / speed_Perihelion)) * 15)
		let meanSpeed = (speed_Aphelion + speed_Perihelion) / 2

		if (speed < meanSpeed && !meanSpeedReached) {
			ctx.strokeStyle = `hsl(230, 100%, 40%)`
			meanSpeedReached = true
			numMeanSpeedReached = alpha
		} else if (sumIntervals > (Period / 4) && !halfPeriodReached) {
			ctx.strokeStyle = `hsl(120, 100%, 20%)`
			halfPeriodReached = true
			numHalfPeriodReached = alpha
		}
		else	
			ctx.strokeStyle = `hsl(${hue}, 100%, ${lit}%)`
 
		ctx.strokeRect(x_EllipsCentr - x, y_EllipsCentr + y, 1, 1)

		prevPos = curPos
		prevSpeed = speed

		console.log(`alpha=${alpha}, x=${x.toFixed(1)}, y=${y.toFixed(1)}, speed=${speed.toFixed(0)}, t=${(interval/secInDay).toFixed(2)},`,
		`date= ${date.toLocaleString('ru')}, dateIdeal= ${dateIdeal.toLocaleString('ru')}, diff=${((date-dateIdeal) / (1000*60*60)).toFixed(2)}`)
		//  `Epot=${Epot.toExponential(1)}, Ekin=${Ekin.toExponential(1)}, Epot-Ekin=${(Epot - Ekin).toExponential(1)}`

		data_history.push({alpha, x, y, speed, interval, date, dateIdeal, diff: date-dateIdeal, Epot, Ekin})
	}

	console.log(`L orbit1=${(LenOrbit*k_Earth).toFixed(0)}`)
	console.log(`L orbit2=${(LenOrbit2*k_Earth).toFixed(0)}`)

	let T_days = Period/secInDay
	console.log(`T orbit=${T_days.toFixed(2)} days, ${(T_days/365.25).toFixed(1)} years`)
	console.log(`sumIntervals=${(sumIntervals / secInDay).toFixed(2)} days, error=${(Period - sumIntervals).toFixed(2)} s`)

	console.log(`numMeanSpeedReached=${numMeanSpeedReached}, numHalfPeriodReached=${numHalfPeriodReached}`)

	let colors = ['Black', 'Blue', 'Green', 'Brown', 'Pink', 'Orange', 'Purple', 'Grey', 'Yellow', 'Red']
	let color = colors[color_i % colors.length]
	color_i++

	let chartHeight = chart.height - 20
	draw_graph( data_history.map( el => el['speed']),    'speed',    0,   10, color, 190, chartHeight, n => n.toFixed(0))
	draw_graph( data_history.map( el => el['interval']), 'interval', 200, 10, color, 190, chartHeight, n => (n / secInDay).toFixed(2))
	draw_graph( data_history.map( el => el['date']),     'date',     400, 10, color, 190, chartHeight, n => (new Date(n)).toLocaleDateString())
	draw_graph( data_history.map( el => el['diff']),     'diff, h',  600, 10, color, 190, chartHeight, n => (n / (1000*60*60)).toFixed(2))
	draw_graph( data_history.map( el => el['Epot']),     'Epot',     800, 10, color, 190, chartHeight, n => n.toExponential(1))
	draw_graph( data_history.map( el => el['Ekin']),     'Ekin',     1000, 10, color, 190, chartHeight, n => n.toExponential(1))

	animationStartTime = performance.now();
	requestAnimationFrame(animate)
}
run()




function draw_graph(data, param, x_start, y_start,  color='pink', width=100, height=50, format = n => n.toFixed(2)) {
	let ctx = document.getElementById('chart').getContext('2d')
	
	let max = Math.max(...data)
	let min =  Math.min(...data)

	let range = max - min
	if (range < min/1000000) range = min/1000000
	let yscale = height / range
	// let xscale = 1
	let xscale = width / data.length
	//console.log(label, yscale)

	let axis_color = 'black'
	let y_axisX = y_start + Math.trunc(height / 2)

	ctx.lineWidth = 1
	ctx.beginPath() // X axis
	ctx.strokeStyle = axis_color
	ctx.moveTo(x_start, y_axisX)
	ctx.lineTo(x_start + width, y_axisX)
	ctx.stroke()
	
	ctx.beginPath() // Y axis
	ctx.moveTo(x_start, y_start)
	ctx.lineTo(x_start, y_start + height)
	ctx.stroke()

	// ctx.lineWidth = 2
	ctx.fillStyle = color
	ctx.font = "12px Arial" // label
	ctx.fillText(param, x_start + width / 2, y_start)

	ctx.fillText(format(max), x_start + 5, y_start + 12)
	ctx.fillText(format(min), x_start + 5, height + 12)

	ctx.moveTo(x_start, height)
	ctx.beginPath()
	ctx.strokeStyle = color
	for (let i=0; i<data.length; i++) {
		ctx.lineTo(x_start + i * xscale, height + y_start - (data[i] - min)*yscale)
	}
	ctx.stroke()
}

function calcR1R2(Perihelion, Aphelion, c, percent) {
	let R2_plus_R1 = Perihelion + Aphelion
	let maxDelta = Aphelion - Perihelion
	let R2 = Perihelion + maxDelta*percent
	let R1 = R2_plus_R1 - R2

	return {R1, R2}
}


function calcDotPosition(R1, R2, c, percent) {
	let x = (R2**2 - R1**2) / (4 * c)
	let y = Math.sqrt(R2**2 - (c + x)**2)

	return {x, y}
}

function calcDotPosition2(a, b, alpha) {
	let x = a * Math.cos(alpha)
	let y = b * Math.sin(alpha)

	return {x, y}
}

function calcOrbitalSpeed(r, a) {
	return Math.sqrt(μ*(2/r - 1/a))
}

let duration_ms = 5000;


function animate(time) 
{
	let timeFraction = (time - animationStartTime) / duration_ms
	if (timeFraction > 1) timeFraction = 1

	let x = x_EllipsCentr - a * Math.cos(timeFraction*2*Math.PI)
	let y = y_EllipsCentr - b * Math.sin(timeFraction*2*Math.PI)

	// planet.style.left = x + "px"; 
	// planet.style.top = y + "px";
	planet.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`

	if (timeFraction < 1 && !checkboxPause.checked) {
		requestAnimationFrame(animate)
	}

}

checkboxPause.onclick = function (event) {
	if (!checkboxPause.checked) 
		requestAnimationFrame(animate)
}

</script>


</body>
</html>